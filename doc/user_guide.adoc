= Safe Arithmetic User Guide
Luke Valenty <luke.valenty@intel.com>
:revnumber: 0.0
:revdate: April 21, 2023
:source-highlighter: rouge
:rouge-style: base16.solarized
:source-language: c++

== Motivation

C++ represents numerical values with finite bounds and discrete steps, as do
all commonly used programming languages and processors. This is not a problem
as long as specific rules regarding overflow, underflow, and loss of precision
are meticulously followed. There are a number of guidelines and standards
published for functional safety and security that detail the rules for safe
arithmetic operations as well as many other concerns:

* https://www.misra.org.uk/publications/[MISRA C and MISRA C++ Guidelines]
* https://wiki.sei.cmu.edu/confluence/display/seccode/SEI+CERT+Coding+Standards[CERT C and CERT C++ Secure Coding Standards]
* https://www.iso.org/standard/61134.html[ISO/IEC TS 17961:2013 (C Secure Coding Rules)]
* https://en.wikipedia.org/wiki/IEC_61508[IEC 61508 (Functional Safety of Electrical/Electronic/Programmable Electronic Safety-related Systems)]

These publications represent a large investment in the safe application of
software, and for good reason. The consequences for such bugs can be catastrophic.

* https://en.wikipedia.org/wiki/Therac-25[Therac-25 radiotherapy machine]. An
  integer overflow caused the machine to bypass software safety checks and
  deliver deadly radiotherapy doses to patients.
* https://en.wikipedia.org/wiki/Ariane_flight_V88[Ariane rocket flight V88].
  An integer overflow was caught, but lead to an exception that was handled
  incorrectly, thus halting its inertial navigation system. This ultimately
  led to the catastrophic destruction of the rocket and its payload.
* https://en.wikipedia.org/wiki/Time_formatting_and_storage_bugs#Boeing[Boeing
  787 computer crash]. Two different integer overflows caused either misleading
  data to be displayed or systems crash.

There are countless other functional bugs and security vulnerabilities all due
to unsafe arithmetic operations.

The Safe Arithmetic library is intended and designed to protect against unsafe
arithmetic operations. This includes overflow, underflow, and divide-by-zero.
It follows the "Valley of success" strategy; The natural state of a software
project utilizing the Safe Arithmetic library contains clear boundaries between
safe and unsafe arithmetic. Within the safe arithmetic environment the easiest
and simplest thing to do is also the safest thing to do. In this context,
arithmetic includes assignment and construction.

=== Numeric Type Support

The current version of the Safe Arithmetic library supports the following value
types:

* C++20 integer primitives
* `safe::integer<N>` arbitrary precision integers

In the future, it is likely support for the following numeric types will be
added:

* Fixed point
* Pointers

It is unlikely that other numeric types, like `float` and `double` will be
supported in the near-term. They at least are not needed by the original author
of the library. That being said, pull-requests are more than welcome and we
greatly appreciate community involvement.

=== Library Inter-op

==== Dimensional Analysis

Dimensional analysis libraries in {cpp} typically use the language's type
system to enforce correct assignment of values with dimensions to variables
or function arguments and forbid nonsensical operations like adding a length
value to a temperature value. Multiplication and division operations of
differing dimensions are allowed and the resulting type represents a new unit
and dimension.

The Safe Arithmetic library also uses the {cpp} type system to enforce correct
operations by encoding the set of possible values in a `safe::var` 's type.
Operations on these `safe::var` s return new types with an updated set of
possible values. The actual runtime value is guaranteed to be within this set.

The {cpp} type system essentially supports sophisticated static analysis
through compilation of the code. It is additionally possible to leverage a
dimensional analysis library like `mp-units` as well as the Safe Arithmetic
library to further increase confidence in your code.

==== Messaging

Intel's Compile-time Initialization and Build library's messaging capabilities
may also be used with great success with the Safe Arithmetic library. Message
fields may be given safe types to enforce correct assignment to fields as well
as provide field values that are already wrapped in safe types when read.

==== Register Access

Intel's internal Config Register Operation Optimizer library may be used with
the Safe Arithmetic library to ensure safe and correct access of registers.
Without the Safe Arithmetic library, it is possible to write values too large
to be represented by a register field's bit width. With the Safe Arithmetic
library, it is possible to ensure only values in range are written to fields
and field read types will also be automatically wrapped in an appropriately
constrained safe type.

=== Similar Libraries

Safe Arithmetic is not the only library that attempts to solve the problem of
unsafe integer or numeric operations in programs. There are a number of other
libraries with different strategies and tradeoffs that are worthwhile to look
at.

* https://github.com/boostorg/safe_numerics[Boost's safe_numerics]. A library
  by Robert Ramey included in Boost. It works on the {cpp}14 standard rather than
  {cpp}20 as required by Safe Arithmetic. It offers more customization points
  on how exceptional cases are handled: compile-time, runtime exceptions, or a
  custom error handler. It also allows customization for how integer promotion
  is handled. It has been around longer than Safe Arithmetic. It only supports
  intervals to specify value requirements, while Safe Arithmetic implements a
  DSL to allow more tightly-constrained requirements.
* https://github.com/dcleblanc/SafeInt[SafeInt]. Provides both a C++11 and C
  library implementation. Appears to only support runtime checking.
* https://github.com/PeterSommerlad/PSsimplesafeint[PSsimplesafeint].
  "A {cpp}20 implementation of safe (wrap around) integers following MISRA
  {cpp} rules."

== Overview

=== Safe Arithmetic Environment

The Safe Arithmetic library uses the C++ type system to encode and enforce
requirements on values. A special template type, `safe::var` is used to contain
these values.

```c++
namespaced safe {
    template<typename ValueType, auto Requirements>
    struct var;
}
```

Arithmetic, bitwise, and shift operators on `safe::var` values results in
the generation of a new `safe::var` with its requirements updated to represent
the set of possible values the result may contain. Operations on `safe::var`
values are guaranteed to be safe at compile-time. There is no runtime overhead
incurred. Only the desired operations are performed.

Operations on instances of `safe::var` forms a hermetically sealed context in
which overflows, underflows, and division-by-zero are proven impossible by
the Safe Arithmetic library implementation. If such a condition were possible
due to an arithmetic operation on a `safe::var`, then compilation would fail.

This leaves two important questions, how to get values in and out of this "Safe
Arithmetic Environment".

=== Creating Safe Values

Safe literal values can be created using the `_i` user defined literal. It will
create a `safe::var` with the necessary integer type to contain the value and
a requirement that matches the value. Literal values larger than 64-bits are
implemented using an arbitrary precision integer type built into the Safe
Arithmetic library.

```c++
namespace safe::literals {
    template <char... chars>
    constexpr auto operator""_i();
}
```

Safe versions of the C++ primitive integer types are available for declaring
runtime values. Each primitive integer type is wrapped in `safe::var` with a
requirement describing the range of that primitive type.

```c++
namespace safe {
    // safe versions of C++ primitive integer types
    using u8 = var<std::uint8_t, ...>;
    using s8 = var<std::int8_t, ...>;
    using u16 = var<std::uint16_t, ...>;
    using s16 = var<std::int16_t, ...>;
    using u32 = var<std::uint32_t, ...>;
    using s32 = var<std::int32_t, ...>;
    using u64 = var<std::uint64_t, ...>;
    using s64 = var<std::int64_t, ...>;
}
```

Because each safe primitive integer type requirement's can contain all values
that are representable by the underlying type, it is safe to directly assign
primitive values to instances of these safe primitive types.

```c++
// SAFE: The signed literal value is gauranteed to fit in a std::int64_t.
safe::s64 foo = 0xc001bea7;

// COMPILE ERROR: On systems with 32- or 64-bit int types, the literal will be
// too large to fit and compilation will fail.
safe::s16 bar_1 = 0xba11;

// SAFE: The safe integer UDL encodes its requirements in its type, the value
// is known at compile-time to fit in bar_2.
safe::s16 bar_2 = 0x5a5_i;

// SAFE: A safe 64-bit int can represent all values in an unsigned safe 16-bit int.
foo = bar_1;

// SAFE: A safe 32-bit unsigned int can safely be assigned the value of a uint32_t
volatile std::uint32_t my_fav_reg;
safe::u32 safe_reg_val = my_fav_reg;

// SAFE: Masking safe_reg_val by an 8-bit value guarantees the result will fit
// in a safe::u8
safe::u8 safe_reg_field_val_1 = safe_reg_val & 0xFF_i;

// COMPILE ERROR: safe::u8 cannot represent all possible values of these rhs
// variables.
safe::u8 safe_reg_field_val_2 = safe_reg_val;
safe::u8 safe_reg_field_val_3 = my_fav_reg;
```

For integer values that cannot fit in the primitive types provided by C++, the
Safe Arithmetic library provides an arbitrary precision implementation,
`safe::integer`.

```c++
namespace safe {
    // safe arbitrary precision signed integer type
    template<std::size_t NumBits>
    using integer = var<...>;
}
```

Safe Arithmetic's integer promotion rules will automatically pick an integer
type large enough to represent the possible values of an arithmetic operation.
There is little need to explicitly use `safe::integer`.

```c++
auto big_int_value = 0xba5eball'd00d5a7e'a11f00d5'900dg00b_i;

// SAFE: The result of the operation is known at compile time to fit.
safe::u64 small_1 = big_int_value >> 64_i;

// COMPILE ERROR: The result cannot be represented by a uint64_t.
safe::u64 small_2 = big_int_value >> 32_i;

volatile safe::u64 hw_reg_1;
volatile safe::u64 hw_reg_2;

// SAFE: The result type is automatically promoted to a safe::integer<66>. The
// 66th bit is the two's complement sign bit and the 65th bit is the carry from
// the 64-bit addition.
auto reg_result = hw_reg_1 + hw_reg_2;

// COMPILE ERROR: The addition of these unchecked values could overflow a
// safe:u64.
safe::u64 reg_result_2 = hw_reg_1 + hw_reg2;

// SAFE: The result is explicitly being masked to 64-bits.
safe::u64 reg_result_3 = (hw_reg_1 + hw_reg2) & 0xFFFF'FFFF'FFFF'FFFF_i;
```


`safe::match` is the only mechanism in the Safe Arithmetic library that will
produce additional runtime overhead. It creates a callable object that may be
called with `safe::var` or naked integer values. It uses compile-time checks
if possible to match the given arguments with the `matchable_funcs` arguments.
If compile-time checks are not possible for an argument, then the value is
checked at runtime to determine if it satisfies the requirements for one of the
`matchable_funcs`. It is analogous to a pattern matching switch statement where
the `matchable_funcs` arguments `safe::var` requirements are the patterns to
match the callable object's input arguments against.

This is the recommended way of marshalling external integer values into a safe
arithmetic environment when the valid values are a subset of the underlying
integer type's range.

```c++
namespace safe {
    template<typename Return>
    auto match<Return>(auto... matchable_funcs, auto default_func);
}
```

The operation of `safe::match` is easier to understand with some examples.

```c++
// Hardware register reporting a count of some event type.
volatile std::uint32_t event_counter_hw_reg;

// Hardware register representing the event type being reported.
volatile std::uint32_t event_type_hw_reg;

// Firmware array keeping track of updated event counts.
safe::array<safe::u16, 17> event_counts{};

constexpr auto process_event_count = safe::match<void>(
    [](
        safe::ival_u32<0, 1023> event_count,
        safe::ival_u32<0, 16> event_type
    ){
        auto const prev_count = event_counts[event_type];
        auto const new_count = prev_count + event_count;

        // this example is making the implementation choice of saturating the
        // event count to prevent overflow and rollover.
        event_counts[event_type] = max(new_count, safe::u16::max_value);
    },

    // Multiple functions with different requirements for parameters may be
    // passed in. The first function whose argument requirements are satisified
    // by the runtime argument values is executed. The last function must be
    // the default handler and is only executed if no prior match is found.

    [](){
        // default action, handle error condition as desired
    }
);

// Hardware triggers this interrupt every time a new event count is ready to
// be processed.
void event_count_interrupt_handler() {
    process_event_count(event_counter_hw_reg, event_type_hw_reg);
}
```

`safe::match` is a powerful tool that is discussed in more detail in the
reference section.

The final method of introducing values into the safe arithmetic environment is
through `unsafe_cast<T>(value)`. It bypasses all compile-time and runtime
safety checks and depends on the value to be proven to satisfy the requirements
of `T` using mechanisms outside the visibility and scope of the Safe Arithmetic
library. Its use is highly discouraged. The name is chosen to cause an uneasy
feeling in programmers and clearly signal a red flag for code reviewers.

```c++
template<typename T>
T unsafe_cast(auto value);
```

`unsafe_cast<T>(value)` is used within the Safe Arithmetic library to ferry
values into instances of `safe::var` after proving it is safe to do so. It is
necessary for the library's construction.

As always, an example is useful to illustrate how to use a particular function.

```c++
std::uint16_t some_function();
void do_something_useful(safe::ival_u32<0, 1024> useful_value);

// VERY DANGEROUS: Don't do this!
auto dangerous_value = unsafe_cast<safe::ival_u32<0, 1024>>(some_function());
do_something_useful(dangerous_value);

// SAFE: Use safe::match instead. This will only call 'do_something_useful'
// if the result of 'some_function' satisfies the requirements on
// 'useful_value'. If it doesn't match, the default callable will be invoked.
safe::match<void>(do_something_useful, [](){})(some_function());

// SAFE: Don't use unsafe_cast<T>(value), try almost everything else first.
```

If you find a case where you feel you must use `unsafe_cast`, then maybe there
is a gap in the Safe Arithmetic API or an algorithm that is missing. Please let
us know by filing an issue.

=== Extracting Safe Values

Extracting values out of the safe arithmetic environment is not dangerous or
unsafe in itself, but it is important to be explicit when doing so.
`safe_cast<T>(value)` is used to extract integer values out of `safe::vars`.
It is an acknowledgement by the programmer they are leaving the safe
environment and must now take on the burden of ensuring safe arithmetic
operations manually. It is also a clear indication for code reviewers to take a
more critical look at any following integer operations.

```c++
template<typename T>
T safe_cast(auto value);

safe::ival_s32<-1000, 1000> my_safe_value = 42_i;

// SAFE: It's OK to use safe_cast to assign to a wider primitive type
auto innocent_value = safe_cast<std::int32_t>(my_safe_value);

// COMPILE ERROR: A narrowing conversion is not allowed by safe_cast
auto another_innocent = safe_cast<std::int8_t>(my_safe_value);
```


=== Safe Arithmetic Requirements